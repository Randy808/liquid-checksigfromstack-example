"use strict";
import { JSONRPCClient } from "json-rpc-2.0";
import {
    networks,
    issuance,
    Transaction,
    address,
    payments,
    confidential,
    script as liquidjsScript,
    witnessStackToScriptWitness,
    Psbt,
} from "liquidjs-lib";
import { hashForWitnessV0 } from "./sighash-helpers";
import fetch from "node-fetch";
import { ECPairFactory } from "ecpair";
let ecc = require("tiny-secp256k1");
let { amountWithPrecisionToSatoshis } = issuance;

let regtest = networks.regtest;

//TEST PRIVATE KEY. NEVER USE FOR SERIOUS PURPOSES.
let privateKeyHex = Buffer.from(
    "968f91395a8d682e5e3dd4a4f19465f1d9122cbbe82a5a624d863c39513a4eed",
    "hex"
);

let ECPair = ECPairFactory(ecc);
let keypair = ECPair.fromPrivateKey(privateKeyHex);

const OP_ADDHASHTYPE: string = `OP_SWAP 83 OP_CAT OP_SWAP`;

//TODO: Add 'OP_SIZE' checks to reduce script malleability and prevent length extension attacks
let globalCov: string =
    `OP_CAT OP_CAT OP_CAT OP_TOALTSTACK ${keypair.publicKey.toString(
        "hex"
    )} OP_2DUP ${OP_ADDHASHTYPE} OP_CHECKSIGVERIFY OP_FROMALTSTACK {covenant_spend_output_sighash} OP_CAT OP_SHA256 OP_SWAP OP_CHECKSIGFROMSTACK`.trim();

let covenantSpendOutputScript = `OP_3 OP_EQUAL`.trim();

let defaultNigiriRpcUser = "admin1";
let defaultNigiriRpcPassword = "123";
let defaultNigiriRpcPort = "18884";

const client = new JSONRPCClient((jsonRPCRequest) =>
    fetch(
        `http://${defaultNigiriRpcUser}:${defaultNigiriRpcPassword}@localhost:${defaultNigiriRpcPort}`,
        {
            method: "POST",
            headers: {
                "content-type": "application/json",
            },
            body: JSON.stringify(jsonRPCRequest),
        }
    ).then((response) => {
        if (response.status === 200) {
            return response
                .json()
                .then((jsonRPCResponse) => client.receive(jsonRPCResponse));
        } else if (jsonRPCRequest.id !== undefined) {
            return Promise.reject(new Error(response.statusText));
        }
    })
);

const LBTC_ASSET_ID = regtest.assetHash;

function extractTransactionFromUnfinishedPset(pset: Psbt) {
    let clonedPset = pset.clone();
    for (let input of clonedPset.data.inputs) {
        input.finalScriptSig = Buffer.from("00");
    }

    return clonedPset.extractTransaction();
}

function extractSighashBuffersFromFullSighashHexString(sighash: string) {
    const MAX_STANDARD_P2WSH_STACK_ITEM_SIZE = 80;
    let buffers: Array<any> = [];
    for (
        let i = 0;
        i < sighash.length;
        //MAX_STANDARD_P2WSH_STACK_ITEM_SIZE*2 because sighash is in hexadecimal
        //and uses 2 characters per byte
        i += MAX_STANDARD_P2WSH_STACK_ITEM_SIZE * 2
    ) {
        let substringBuffer = Buffer.from(sighash.substring(i, i + 160), "hex");
        buffers.push(substringBuffer);
    }
    return buffers;
}

async function getCovenantSpendOutputSighash(
    lbtcAmount: number
): Promise<string> {
    const nonce = Buffer.from("00", "hex");
    const lbtcBuffer = Buffer.concat([
        Buffer.from("01", "hex"),
        Buffer.from(LBTC_ASSET_ID, "hex").reverse(),
    ]);

    //Generate the hash for the script that will serve as the address as per bip-0141 (segwit)
    let { address: p2wshAddress } = payments.p2wsh({
        redeem: { output: liquidjsScript.fromASM(covenantSpendOutputScript) },
        network: regtest,
    });

    //If a hash wasn't able to be generated by the script
    if (!p2wshAddress) {
        //Then terminate with an error
        throw new Error(
            `Could not generate witness hash for script: ${covenantSpendOutputScript}`
        );
    }

    //Create the output that will be enforced on the spend transaction from the covenant
    let covenantSpendOutput = {
        asset: lbtcBuffer,
        value: confidential.satoshiToConfidentialValue(
            amountWithPrecisionToSatoshis(lbtcAmount) - 1000
        ),
        script: address.toOutputScript(p2wshAddress),
        nonce,
    };

    //Create a pset that will be used in the 'hashForWitnessV0' helper function
    let pset = new Psbt({ network: regtest }).addOutput(covenantSpendOutput);

    //Get the serialized version of the output
    let outputSighashBuffer = hashForWitnessV0(
        pset.extractTransaction(),
        0,
        Transaction.SIGHASH_SINGLE | Transaction.SIGHASH_ANYONECANPAY,
        true
    );
    return outputSighashBuffer.toString("hex");
}

async function spendToCovenant(
    script,
    fundingLbtcTxDetails,
    fundingLbtcTxVout,
    lbtcAmount,
    rpcClient
) {
    let { address: p2wshAddress } = payments.p2wsh({
        redeem: { output: liquidjsScript.fromASM(script) },
        network: regtest,
    });

    if (!p2wshAddress) {
        return;
    }

    const lbtcBuffer = Buffer.concat([
        Buffer.from("01", "hex"),
        Buffer.from(LBTC_ASSET_ID, "hex").reverse(),
    ]);

    let lbtcScript = Buffer.from(
        fundingLbtcTxDetails.vout[fundingLbtcTxVout].scriptPubKey.hex,
        "hex"
    );

    const nonce = Buffer.from("00", "hex");

    let lbtcInput = {
        hash: fundingLbtcTxDetails.txid,
        index: fundingLbtcTxVout,
        witnessUtxo: {
            asset: lbtcBuffer,
            script: lbtcScript,
            value: confidential.satoshiToConfidentialValue(
                amountWithPrecisionToSatoshis(lbtcAmount)
            ),
            nonce,
        },
        sighashType:
            Transaction.SIGHASH_SINGLE | Transaction.SIGHASH_ANYONECANPAY,
    };

    let pset = new Psbt({ network: regtest });
    pset.addInput(lbtcInput)
        .addOutput({
            asset: lbtcBuffer,
            value: confidential.satoshiToConfidentialValue(
                amountWithPrecisionToSatoshis(lbtcAmount) - 500
            ),
            script: address.toOutputScript(p2wshAddress),
            nonce,
        })
        .addOutput({
            nonce,
            asset: lbtcBuffer,
            value: confidential.satoshiToConfidentialValue(500),
            script: Buffer.alloc(0),
        });

    pset.signInput(0, keypair, [
        Transaction.SIGHASH_SINGLE | Transaction.SIGHASH_ANYONECANPAY,
    ]);

    pset.finalizeAllInputs();
    let tx = pset.extractTransaction().toHex();
    console.log("\n\nTransaction Hex:\n\n");
    console.log(tx);
    console.log("\n\n");
    return rpcClient.request(`sendrawtransaction`, [tx]);
}

async function spendFromCovenant(
    scriptInput,
    lbtcTxIdSource,
    lbtcIndex,
    lbtcAmount,
    rpcClient
) {
    lbtcTxIdSource = Buffer.from(lbtcTxIdSource, "hex")
        .reverse()
        .toString("hex");

    const nonce = Buffer.from("00", "hex");

    const lbtcBuffer = Buffer.concat([
        Buffer.from("01", "hex"),
        Buffer.from(LBTC_ASSET_ID, "hex").reverse(),
    ]);

    let { address: inputP2wshAddress } = payments.p2wsh({
        redeem: { output: liquidjsScript.fromASM(scriptInput) },
        network: regtest,
    });

    if (!inputP2wshAddress) {
        return;
    }

    let input0 = {
        hash: Buffer.from(lbtcTxIdSource, "hex"),
        index: lbtcIndex,
        witnessScript: liquidjsScript.fromASM(scriptInput),
        witnessUtxo: {
            asset: lbtcBuffer,
            script: address.toOutputScript(inputP2wshAddress),
            value: confidential.satoshiToConfidentialValue(
                amountWithPrecisionToSatoshis(lbtcAmount) - 500
            ),
            nonce,
        },
        sighashType:
            Transaction.SIGHASH_SINGLE | Transaction.SIGHASH_ANYONECANPAY,
    };

    let { address: covenantEnforcedOutputAddress } = payments.p2wsh({
        redeem: { output: liquidjsScript.fromASM(covenantSpendOutputScript) },
        network: regtest,
    });

    if (!covenantEnforcedOutputAddress) {
        return;
    }

    let pset = new Psbt({ network: regtest });
    pset.addInput(input0)
        .addOutput({
            asset: lbtcBuffer,
            value: confidential.satoshiToConfidentialValue(
                amountWithPrecisionToSatoshis(lbtcAmount) - 1000
            ),
            script: address.toOutputScript(covenantEnforcedOutputAddress),
            nonce,
        })
        //NEED TO ACCOUNT FOR FEE
        .addOutput({
            nonce,
            asset: lbtcBuffer,
            value: confidential.satoshiToConfidentialValue(500),
            script: Buffer.alloc(0),
        });

    let serializedOutputBuffer: Buffer = hashForWitnessV0(
        extractTransactionFromUnfinishedPset(pset),
        0,
        Transaction.SIGHASH_SINGLE | Transaction.SIGHASH_ANYONECANPAY,
        false,
        true,
        input0.witnessScript,
        input0.witnessUtxo.value
    );

    let buffers = extractSighashBuffersFromFullSighashHexString(
        serializedOutputBuffer.toString("hex")
    );

    //Sign input so we can get a signature
    pset.signInput(0, keypair, [
        Transaction.SIGHASH_SINGLE | Transaction.SIGHASH_ANYONECANPAY,
    ]);

    //Remove the hash type because we'll enforce the hash type in our locking script
    let signature = pset?.data?.inputs?.[0]?.partialSig?.[0]?.signature
        ?.toString("hex")
        ?.slice(0, -2);

    if (!signature) {
        throw new Error("Signature could not be generated");
    }

    //Clear the signature since we'll be constructing the witness ourselves manually
    pset.data.inputs[0].partialSig = [];
    pset.data.inputs[0].finalScriptWitness = witnessStackToScriptWitness([
        Buffer.from(signature, "hex"),
        ...buffers,
        liquidjsScript.fromASM(scriptInput),
    ]);

    let tx = pset.extractTransaction().toHex();

    console.log("\n\nTransaction Hex:\n\n", tx, "\n\n");
    return rpcClient.request(`sendrawtransaction`, [tx]);
}

let getOutputForAssetId = (tx, assetId) => {
    let { vout } = tx;

    for (let i = 0; i < vout.length; i++) {
        if (vout[i].asset == assetId && vout[i].scriptPubKey.asm) {
            return i;
        }
    }

    return -1;
};

async function startDemo() {
    const lbtcAmount = 10;

    const testAddress = "ert1qrpxstycc2desapdg3xzcd6vmgmzym749s577v7";

    let balanceTest = await client.request(`getbalance`);

    console.log(balanceTest);

    let regtestFaucetLbtcTxId = await client.request(`sendtoaddress`, [
        testAddress,
        lbtcAmount,
    ]);

    let regtestFaucetLbtcTxDetails = await client.request("getrawtransaction", [
        regtestFaucetLbtcTxId,
        true,
    ]);

    let regtestFaucetLbtcTxVout = getOutputForAssetId(
        regtestFaucetLbtcTxDetails,
        LBTC_ASSET_ID
    );

    let covenantSpendOutputSighash = await getCovenantSpendOutputSighash(
        lbtcAmount
    );

    let finalizedCovenantScript = globalCov.replace(
        "{covenant_spend_output_sighash}",
        covenantSpendOutputSighash
    );

    let spendToCovenantTxId = await spendToCovenant(
        finalizedCovenantScript,
        regtestFaucetLbtcTxDetails,
        regtestFaucetLbtcTxVout,
        lbtcAmount,
        client
    );

    console.log("\n\nTXID: ", spendToCovenantTxId);

    let spendToCovenantTxDetails = await client.request("getrawtransaction", [
        spendToCovenantTxId,
        true,
    ]);

    let spendToCovenantLbtcChangeVout = getOutputForAssetId(
        spendToCovenantTxDetails,
        LBTC_ASSET_ID
    );

    console.log(`LBTCVOUT: ${spendToCovenantLbtcChangeVout}`);

    let spendFromCovenantTxId = await spendFromCovenant(
        finalizedCovenantScript,
        spendToCovenantTxId,
        spendToCovenantLbtcChangeVout,
        lbtcAmount,
        client
    );

    console.log("COMPLETED: ", spendFromCovenantTxId);
}

startDemo();
